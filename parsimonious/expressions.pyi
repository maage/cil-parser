# SPDX-FileCopyrightText: 2021 Erik Rose
#
# SPDX-License-Identifier: MIT

from parsimonious.exceptions import IncompleteParseError as IncompleteParseError, ParseError as ParseError
from parsimonious.nodes import Node as Node, RegexNode as RegexNode
from parsimonious.utils import StrAndRepr as StrAndRepr
from typing import (
    Any,
    Text,
    Tuple,
)

MARKER: Any

def expression(callable: Any, rule_name: Any, grammar: Any) -> Expression: ...

class Expression(StrAndRepr):
    name: str = ...
    identity_tuple: Tuple[str, Any] = ...
    def __init__(self, name: str = ...) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def parse(self, text: Text, pos: int = ...) -> Node: ...
    def match(self, text: Text, pos: int = ...) -> Node: ...
    def match_core(self, text: Text, pos: int, cache: Any, error: Any) -> Node: ...
    def as_rule(self) -> Text: ...

class Literal(Expression):
    literal: Text  = ...
    identity_tuple: Tuple[str, Text] = ...
    def __init__(self, literal: Text, name: str = ...) -> None: ...

class TokenMatcher(Literal): ...

class Regex(Expression):
    re: Any = ...
    identity_tuple: Any = ...
    def __init__(self, pattern: Any, name: str = ..., ignore_case: bool = ..., locale: bool = ..., multiline: bool = ..., dot_all: bool = ..., unicode: bool = ..., verbose: bool = ...) -> None: ...

class Compound(Expression):
    members: Any = ...
    def __init__(self, *members: Any, **kwargs: Any) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...

class Sequence(Compound): ...
class OneOf(Compound): ...
class Lookahead(Compound): ...
class Not(Compound): ...
class Optional(Compound): ...
class ZeroOrMore(Compound): ...

class OneOrMore(Compound):
    min: Any = ...
    def __init__(self, member: Any, name: str = ..., min: int = ...) -> None: ...
